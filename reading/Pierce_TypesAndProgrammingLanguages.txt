----------------------------------------------------------------
B. C. Pierce. Types and programming languages. MIT Press, 2002.
ISBN 978-0-262-16209-8.
----------------------------------------------------------------

Notes:

runtime tags in structural type systems:

Run-time type tags can also be supported in structural sys-
tems (see Glew, 1999; League, Shao, and Trifonov, 1999; League, Trifonov, and
Shao, 2001; and the citations given there)


support for recursive types is easier in nominal type systems:

A less essential, but pleasant, property of nominal systems is that they of-
fer a natural and intuitive account of recursive types—types whose definition
mentions the type itself. (We will discuss recursive types in detail in Chap-
ter 20.) Such types are ubiquitous in serious programming, being required to
describe such common structures as lists and trees, and nominal type sys-
tems support them in the most straightforward possible way: referring to
List in the body of its own declaration is just as easy as referring to any
other type. Indeed, even mutually recursive types are straightforward. We
view the set of type names as being given from the beginning, so that, if the
definition of type A involves the name B and the definition of B refers to A,
there is no issue about “which is defined first.” Of course, recursive types can
also be handled in structural type systems. Indeed, high-level languages with
structural typing, such as ML, generally “bundle” recursive types with other
features, so that, for the programmer, they are just as natural and easy to
use as in nominal languages. But in calculi intended for more foundational
purposes, such as type safety proofs, the mechanisms required to deal rig-
orously with recursive types can become rather heavy, especially if mutually
recursive types are allowed. The fact that recursive types come essentially for
free in nominal systems is a decided benefit.


equi-recursive presentation of recursive types

NatList = μX. <nil:Unit, cons:{Nat,X}>;
“Let NatList be the infinite type satisfying the equation X = <nil:Unit, cons:{Nat,X}>.”
not only equi-recursive, but also iso-recursive presentation


functional objects also require recursive types:

For instance, here is the type of counter objects
that keep track of a number and allow us to either query or increment it:
Counter = μC. {get:Nat, inc:Unit→C};
Note that our treatment of objects here is purely functional (like the one in
Chapter 19 and unlike Chapter 18): sending a counter object the inc message
does not cause this object to mutate its state internally; instead, the opera-
tion returns a new counter object with incremented internal state. The use of
recursive types here allows us to specify that the returned object has exactly
the same type as the original.




